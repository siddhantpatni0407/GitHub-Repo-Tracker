name: Update README Last Updated (on external repo change)

permissions:
  contents: write

on:
  repository_dispatch:
    types: [repo_changed]

jobs:
  update-last-updated:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug: show event (for logs)
        if: always()
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          echo "Event payload:"
          jq '.' "$GITHUB_EVENT_PATH" || true

      - name: Update Last Updated date in README
        env:
          TZ: 'Asia/Kolkata'
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail

          README="README.md"
          if [ ! -f "$README" ]; then
            echo "README not found at expected path. Exiting."
            exit 0
          fi

          # compute date
          NEW_DATE="$(date '+%Y-%m-%d %H:%M %z')"
          echo "Updating Last Updated â†’ $NEW_DATE in $README"

          # If client_payload provided, we can log which repo triggered this
          if [ -f "$GITHUB_EVENT_PATH" ]; then
            SRC_REPO=$(jq -r '.client_payload.source_repo // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo "")
            SRC_BRANCH=$(jq -r '.client_payload.source_branch // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo "")
            SRC_SHA=$(jq -r '.client_payload.source_commit // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo "")
            SRC_ACTOR=$(jq -r '.client_payload.actor // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo "")
            echo "Triggered by: $SRC_REPO $SRC_BRANCH $SRC_SHA $SRC_ACTOR"
          fi

          # Replace 'Last Updated' occurrences (lines containing 'Last Updated') with new date
          if grep -q -E 'Last Updated' "$README"; then
            # Replace first occurrence only
            awk -v d="$NEW_DATE" '
              BEGIN { done=0 }
              {
                if (done==0 && /Last Updated/) {
                  gsub(/.*Last Updated.*/, "## ðŸ“… Last Updated : `" d "`")
                  print
                  done=1
                  next
                }
                print
              }
            ' "$README" > /tmp/README.tmp && mv /tmp/README.tmp "$README"
          else
            # Insert after first H1 (# Title) or prepend if none
            if grep -q '^# ' "$README"; then
              awk -v d="$NEW_DATE" 'NR==1{print; print ""; print "## ðŸ“… Last Updated : `" d "`"; next}1' "$README" > /tmp/README.tmp && mv /tmp/README.tmp "$README"
            else
              printf "## ðŸ“… Last Updated : `%s`\n\n" "$NEW_DATE" > /tmp/README.tmp
              cat "$README" >> /tmp/README.tmp
              mv /tmp/README.tmp "$README"
            fi
          fi

          git --no-pager diff -- "$README" || true

      - name: Commit & push if changed
        env:
          GIT_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_NAME: github-actions[bot]
        run: |
          set -euo pipefail
          git config user.email "$GIT_EMAIL"
          git config user.name "$GIT_NAME"

          # commit only if changed
          if git status --porcelain | grep -q "$(basename "$README")"; then
            git add "$README"
            git commit -m "chore: update Last Updated timestamp (external repo change)"
            git push origin HEAD:${{ github.ref_name }}
          else
            echo "No README changes to commit."
          fi
